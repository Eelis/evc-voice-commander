#!/usr/bin/env python3

import time
import os
import subprocess
import sys
import re
import itertools
import fileinput
import collections
import threading
import shutil
import termcolor
from contextlib import contextmanager
from ctypes import *
import click
import yaml

os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "hide"

sound_effects = False
mode = None
modes = {}
numbers = {}
word_replacements = {}
enums = {}
completions = {}
ignore = ["i", "of", "the", "if"]
current_windowpid = ''
current_windowtitle = ''
current_windowprocesses = {}
debug = False
dryrun = False
prompt = True
color = True
explicitly_autoenabled = []
scriptvars = {}
suggestions = []

def colored(s, c):
    if not color: return s
    return termcolor.colored(s, c)

extra_key_names = {
    'space': ' ',
    'dollar': '$',
    'ampersand': '&',
    'hash': '#',
    'colon': ':',
    'semicolon': ';',
    'percent': '%',
    'period': '.',
    'comma': ',',
    'slash': '/',
    'wmkey': 'winleft'
}

short_mode_names = {}
configdir = ''
auto_enable_cfg = {}
global_builtins = ['options', 'define', 'builtin']
    # this order is also used for display to humans

def load_yaml(f):
    with open(f, 'r') as stream:
        return yaml.load(stream, yaml.CLoader)

def load_config():
    global word_replacements, numbers, modes, enums, completions, short_mode_names, auto_enable_cfg
    short_mode_names = {}
    auto_enable_cfg = {}
    try:
        word_replacements = load_yaml(configdir + '/replacements.yaml')
        numbers = load_yaml(configdir + '/numbers.yaml')
        modes = load_yaml(configdir + '/modes.yaml')

        # handle enums:
        enums = {}
        completions = {}
        for key, v in modes.items():
            if key.startswith('<'):
                n = key[1:-1]
                if type(v) is dict:
                    if 'completions' in v:
                        completions[n] = v['completions']
                    v = v['forms']
                if type(v) is list: v = '/'.join(v)
                enums[n] = v
        for e in enums:
            del modes['<' + e + '>']

        # handle shortnames:
        def remove_shortname(s):
            i = s.find('(')
            return (s if i == -1 else s[:i].strip())
        for mode, aliases in modes.items():
            realname = remove_shortname(mode)
            if realname != mode:
                shortname = mode[mode.find('(') + 1: -1]
                short_mode_names[realname] = shortname
        modes = dict([(remove_shortname(m), a) for m, a in modes.items()])

        # handle auto-enabling:
        for mode, aliases in modes.items():
            cfg = {}
            if 'auto-enable' in aliases:
                cfg = aliases['auto-enable']
                del aliases['auto-enable']
            if 'always' not in cfg: cfg['always'] = False
            if 'built-ins' not in cfg: cfg['built-ins'] = True
            if 'other-modes' not in cfg: cfg['other-modes'] = True
            cfg['for-applications'] = (cfg['for-applications'].split() if 'for-applications' in cfg else [])
            cfg['for-leaf-applications'] = (cfg['for-leaf-applications'].split() if 'for-leaf-applications' in cfg else [])
            if 'for-prefixes' not in cfg: cfg['for-prefixes'] = []
            if 'for-suffixes' not in cfg: cfg['for-suffixes'] = []
            auto_enable_cfg[mode] = cfg

    except Exception as e:
        print("\nerror loading config:", e)

def key_by_name(name):
    return (extra_key_names[name] if name in extra_key_names else name)

# built-in commands:

def is_global_builtin_pattern(pat):
    pat = pat.split()
    while pat != [] and pat[0][0] == '<':
        pat = pat[1:]
    return pat != [] and pat[0] in global_builtins

keynames = ['\t', '\n', '\r', ' ', '!', '"', '#', '$', '%', '&', "'", '(',
    ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '^', '_', '`',
    'a', 'b', 'c', 'd', 'e','f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~',
    'accept', 'add', 'alt', 'altleft', 'altright', 'apps', 'backspace',
    'browserback', 'browserfavorites', 'browserforward', 'browserhome',
    'browserrefresh', 'browsersearch', 'browserstop', 'capslock', 'clear',
    'convert', 'ctrl', 'ctrlleft', 'ctrlright', 'decimal', 'del', 'delete',
    'divide', 'down', 'end', 'enter', 'esc', 'escape', 'execute', 'f1', 'f10',
    'f11', 'f12', 'f13', 'f14', 'f15', 'f16', 'f17', 'f18', 'f19', 'f2', 'f20',
    'f21', 'f22', 'f23', 'f24', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9',
    'final', 'fn', 'hanguel', 'hangul', 'hanja', 'help', 'home', 'insert', 'junja',
    'kana', 'kanji', 'launchapp1', 'launchapp2', 'launchmail',
    'launchmediaselect', 'left', 'modechange', 'multiply', 'nexttrack',
    'nonconvert', 'num0', 'num1', 'num2', 'num3', 'num4', 'num5', 'num6',
    'num7', 'num8', 'num9', 'numlock', 'pagedown', 'pageup', 'pause', 'pgdn',
    'pgup', 'playpause', 'prevtrack', 'print', 'printscreen', 'prntscrn',
    'prtsc', 'prtscr', 'return', 'right', 'scrolllock', 'select', 'separator',
    'shift', 'shiftleft', 'shiftright', 'sleep', 'space', 'stop', 'subtract', 'tab',
    'up', 'volumedown', 'volumemute', 'volumeup', 'win', 'winleft', 'winright', 'yen',
    'command', 'option', 'optionleft', 'optionright']
        # these coincide with names in pyautogui
        # (which we don't want to import just for this list because it takes ~60 milliseconds)

def is_keyname(s):
    return s in keynames or s in extra_key_names

all_keys = keynames + list(extra_key_names.keys())

def is_keyspec(spec):
    for combo in spec.split(','):
        mult = combo.find('*')
        if mult != -1:
            if not combo[:mult].isdigit(): return False
            combo = combo[mult+1:]
        for k in combo.split('+'):
            if not is_keyname(k): return False
    return True

builtin_commands = {}

def make_builtin(pattern):
    def f(g):
        builtin_commands[pattern] = (None, g)
        return g
    return f

def make_functional_builtin(pattern):
    def f(g):
        builtin_commands[pattern] = (g, None)
        return g
    return f

@make_builtin('set <word> <word>')
def cmd_set(_, var, val):
    global scriptvars
    scriptvars[var] = val

@make_functional_builtin('get <word>')
def cmd_get(_, var):
    return scriptvars[var] if var in scriptvars else "undefined"

jobs = {}
next_job_nr = 0

@make_builtin('jobs')
def cmd_jobs(_):
    if jobs == {}:
        print('No active jobs.')
        return
    for n, cmd in jobs.items():
        print(str(n) + ':', cmd)

@make_builtin('cancel job <job>')
def cmd_cancel_job(_cancel, _job, n):
    n = int(n)
    if n in jobs: del jobs[n]

@make_builtin('window processes')
def cmd_window_processes(*_):
    print_pstree(current_windowprocesses, 2)

@make_builtin('asynchronously <command>')
def cmd_asynchronously(_, mode, cmd):
    global jobs, next_job_nr
    pr = process(split_expansion(cmd), mode)
    n = next_job_nr
    next_job_nr += 1
    jobs[n] = cmd
    def f():
        # todo: VERY EVIL unsafe concurrent access to 'jobs' below
        status = 'finished'
        for act, w in pr.actions:
            if n not in jobs:
                status = 'canceled'
                break
            act(*w)
        if n in jobs: del jobs[n]
        print(' ', status + ':', colored(cmd, 'green'))
        if prompt: print_prompt()
    threading.Thread(target=f).start()

def action(cmd, mode):
    pr = process(split_expansion(cmd), mode)
    def combined():
        for f, w in pr.actions:
            f(*w)
    return combined

@make_builtin('run <words>')
def cmd_run(_, cmd):
    if dryrun: return
    subprocess.Popen(
        split_expansion(cmd), shell=False, close_fds=True,
        stdin=subprocess.DEVNULL,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL)

@make_builtin('execute <words>')
def cmd_execute(_, cmd):
    if dryrun: return
    output = subprocess.Popen(
        split_expansion(cmd), shell=False,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE).stdout.read().decode('utf-8').strip()
    cmd_print('print', output)

@make_builtin('restart')
def cmd_restart(_):
    os.execl(sys.argv[0], *sys.argv)

@make_builtin('keydown <key>')
def press_key(_, key_name):
    if not dryrun:
        import pyautogui
        pyautogui.keyDown(key_by_name(key_name))

@make_builtin('keyup <key>')
def release_key(_, key_name):
    if not dryrun:
        import pyautogui
        pyautogui.keyUp(key_by_name(key_name))

@make_builtin('nop')
def cmd_nop(_):
    pass

@make_builtin('shutdown')
def cmd_exit(_):
    sys.stdout.write("\033[?25h") # restore cursor
    sys.exit(0)

@make_functional_builtin('<number> plus <number>')
def cmd_plus(x, _p, y):
    return int(x) + int(y)

@make_functional_builtin('<number> minus <number>')
def cmd_minus(x, _p, y):
    return int(x) - int(y)

@make_functional_builtin('<number> times <number>')
def num_times_num(x, _p, y):
    return int(x) * int(y)

@make_functional_builtin('<number> is less than <number>')
def cmd_less_than(x, _is, _less, _than, y):
    return "true" if int(x) < int(y) else "false"

@make_functional_builtin('<number> is greater than <number>')
def cmd_less_than(x, _is, _greater_, _than, y):
    return "true" if int(x) > int(y) else "false"

@make_functional_builtin('enumindex <word> <word>')
def cmd_enumindex(_, e, v):
    l = enums[e].split('/')
    return l.index(v) if v in l else -1

# times and overloading

@make_builtin('define <command>')
def cmd_define(_, *cmd):
    for m in get_active_modes(mode):
        for pattern in modes[m].keys():
            matched, missing, _ = params_matched(pattern.split(), list(cmd), mode)
            if matched > 0 and missing == []:
                print('\nin ', end='')
                print(alias_definition_str(m, pattern, len('in ')))
                print()
                return
    for pattern, _ in builtin_commands.items():
        matched, missing, _ = params_matched(pattern.split(), list(cmd), mode)
        if matched > 0 and missing == []:
            print_builtin(pattern)

ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
def strip_markup(s):
    return ansi_escape.sub('', s)

turn_on_italic = "\x1B[3m"
turn_off_italic = "\x1B[23m"

def italic(s):
    return turn_on_italic + s + turn_off_italic if color else s

def italic_types(pattern):
    return '/'.join(
            [' '.join(
                ['|'.join(
                    [ (italic(alt[1:-1]) if alt.startswith('<') else alt)
                        for alt in param.split('|')
                    ])
                    for param in form.split(' ')
                ])
                for form in pattern.split('/')])

@make_builtin('options')
def cmd_options(_):
    mm = get_active_modes(mode)
    print()
    builtins_displayed = []

    def command_pattern(pat):
        return color_commands(italic_types(pat)) + ', '

    def simple_pattern(pat):
        return italic_types(pat) + ', '

    for m in mm:
        indent = len(m) + len("in : ")
        l = []
        simples = []
        for pat, exp in modes[m].items():
            if exp == 'builtin $*':
                for form in pat.split('/'):
                    simples.append(simple_pattern(form))
            elif exp == 'builtin press $0':
                if len(pat.split()) == 1:
                    for alt in pat.split('|'):
                        simples.append(simple_pattern(alt))
                else:
                    simples.append(simple_pattern(pat))
            elif not pat.startswith('_'):
                for form in pat.split('/'):
                    if ' ' in form:
                        l.append(command_pattern(form))
                    else:
                        for alt in form.split('|'):
                            l.append(command_pattern(alt))
        l += simples
        for pat, exp in modes[m].items():
            if pat in modes and pat != m and exp == 'builtin mode ' + pat:
                l.append(color_mode(pat) + ', ')
        if l != []:
            print('in', color_mode(m) + ': ', end='')
            s = l[-1]; l[-1] = s[:-2] # remove last comma
            print(indented_and_wrapped(l, indent), end='\n\n')

    l = [italic_types(b) + ', ' for b in builtin_commands.keys() if is_global_builtin_pattern(b)]
    if l != []:
        print('global: ', end='')
        indent = len('global: ')
        s = l[-1]; l[-1] = s[:-2] # remove last comma
        print(indented_and_wrapped(l, indent), end='\n\n')

@make_builtin('text <word>')
def cmd_text(_, s):
    if not dryrun:
        import pyautogui
        pyautogui.press([c for c in s])

@make_builtin('mode <mode>')
def cmd_mode(_, new_mode):
    global mode
    mode = new_mode

@make_functional_builtin('return <word>')
def cmd_return(_, w):
    return w

@make_builtin('press <keys>')
def cmd_press(_, spec):
    if dryrun: return
    import pyautogui
    for combo in spec.split(','):
        times = 1
        mult = combo.find('*')
        if mult != -1:
            times = int(combo[:mult])
            combo = combo[mult+1:]
        keys = combo.split('+')
        if len(keys) == 1:
            k = key_by_name(keys[0])
            pyautogui.press([k] * times)
        else:
            for i in range(times):
                for k in keys: press_key('press', k)
                time.sleep(0.05)
                for k in reversed(keys): release_key('release', k)

@make_builtin('print <word>')
def cmd_print(_, s):
    print(colored(s, 'magenta'))

# command evaluation:

builtin_types = {
    'word': lambda _: True,
    'number': lambda s: s.isdigit(),
    'job': lambda n: n.isdigit() and int(n) in jobs,
    'key': is_keyname,
    'keys': is_keyspec,
    'mode':
        lambda m: m in modes.keys()
}

def param_matched(param, args, mode):
    arg = args[0]
    for alt in param.split('|'):
        if alt == arg: return (1, [])
        if alt.startswith('<'): # oh it's a type
            type = alt[1:-1]
            if type in builtin_types:
                pred = builtin_types[type]
                if pred(arg): return (1, [])
            elif type in enums:
                matched, _v, mis, _pat, _r = longest_matching_pattern([(enums[type], None)], args, mode)
                if matched != 0: return (matched, mis)
    return (0, [param])

def params_matched(params, args, mode, i = 0):
    vars = []
    args_matched = 0
    missing = []
    while i < len(params):
        if args == []:
            break

        varieties = []

        if args[:1] == ['evaluate']:
            sub = args[1:]
            pr = process(sub, mode, True, True)
            varieties.append((pr.longest, pr.missing, [str(pr.retval)] + sub[pr.longest:], [], i))
                # not i+1 because still on same parameter
                # we would need to add 1 to pr.longest to account for having consumed 'evaluate',
                # but this is canceled out by a -1 to account for the newly inserted argument.

        if params[i] == '<command>':
            pr = process(args, mode, True, True)
            varieties.append(
                ( pr.longest, pr.missing, args[pr.longest:]
                , [mode, ' '.join(map(quote_if_necessary, args[:pr.longest]))]
                , i + 1))
        elif params[i] == '<words>':
            varieties.append((len(args), [], [], [' '.join(map(quote_if_necessary, args))], i + 1))
        else:
            am, miss = param_matched(params[i], args, mode)
            varieties.append((am, miss, args[am:], [' '.join(args[:am])], i + 1))

        longest_here = 0
        vars_here = []

        for n, mis, a, v, ni in varieties:
            if n == longest_here:
                if mis == [] and missing != []:
                    missing = []
                    args = a
                    vars_here = v
                    i = ni
                else:
                    missing += mis
            elif n > longest_here:
                longest_here = n
                missing = mis
                args = a
                vars_here = v
                i = ni

        vars += vars_here
        args_matched += longest_here

        if missing != []: # or i is None:
            break

    if i < len(params) and missing == []:
        missing = [params[i]]
    return (args_matched, missing, vars)

terminal_apps = ['urxvt']

def pstree_branch(pids, names, children, stop_on_terminal=False):
    r = {}
    for pid in pids:
        name = (names[pid] if pid in names else '?')
        if stop_on_terminal and name in terminal_apps: continue
        b = (pstree_branch(children[pid], names, children, True) if pid in children else {})
        b['name'] = name
        r[pid] = b
    return r

def process_family(pid):
    import psutil
    children = collections.defaultdict(list)
    names = {}
    for p in psutil.process_iter():
        try:
            children[p.ppid()].append(p.pid)
            names[p.pid] = p.name()
        except (psutil.NoSuchProcess, psutil.ZombieProcess):
            pass
    start = [pid]
    return pstree_branch(start, names, children)

def occurs_in_branch(x, processes):
    for k, v in processes.items():
        if k == 'name':
            if v == x: return True
        elif occurs_in_branch(x, v):
            return True
    return False

def occurs_as_leaf_in_branch(x, processes):
    if len(processes) == 1 and 'name' in processes and processes['name'] == x:
        return True
    for k, v in processes.items():
        if k != 'name' and occurs_as_leaf_in_branch(x, v):
            return True
    return False

def mode_is_auto_enabled(current_mode, candidate):
    c = auto_enable_cfg[current_mode]
    if not c['other-modes']: return False

    if candidate in explicitly_autoenabled: return True

    c = auto_enable_cfg[candidate]
    if c['always']: return True
    for app in c['for-applications']:
        if occurs_in_branch(app, current_windowprocesses): return True
    for app in c['for-leaf-applications']:
        if occurs_as_leaf_in_branch(app, current_windowprocesses): return True
    for prefix in c['for-prefixes']:
        if current_windowtitle.startswith(prefix): return True
    for suffix in c['for-suffixes']:
        if current_windowtitle.endswith(suffix): return True
    return False

def get_active_modes(mode):
    return [mode] + [m for m in modes if m != mode and mode_is_auto_enabled(mode, m)]
        # important: mode itself comes first

def color_commands(p):
    return colored(p, 'magenta')

def color_mode(m):
    return colored(m, 'cyan')

def split_expansion(s):
    if s == '': return []
    if s[0] == '"':
        x = ''
        i = 1
        while s[i] != '"':
            if s[i:].startswith('\\"'):
                x += '"'
                i += 2
            elif s[i:].startswith('\\\\'):
                x += '\\'
                i += 2
            else:
                x += s[i]
                i += 1
        if i + 1 == len(s): return [x]
        afterspace = i + 1
        while s[afterspace] == ' ': afterspace += 1
        return [x] + split_expansion(s[afterspace:])
    space = s.find(' ')
    if space == -1: return [s]
    afterspace = space + 1
    while afterspace < len(s) and s[afterspace] == ' ': afterspace += 1
    return [s[:space]] + split_expansion(s[afterspace:])

def longest_matching_pattern(patterns, input, mode):
    # if multiple patterns match equally well, the first one of them is returned
    # (this is important because it's how commands in the current mode
    #  override commands in auto-enabled modes)

    longest = 0
    vars = None
    missing = []
    pattern = None
    result = None

    if debug:
        print("finding longest pattern matching", input, "among", [p for p, _ in patterns])

    for p, r in patterns:
        for form in p.split('/'):
            params = form.split()
            matched, mis, v = params_matched(params, input, mode)

            if matched == longest:
                if mis != [] and missing != []:
                    missing += mis
                elif missing != []:
                    missing = []
                    pattern = p
                    result = r
                    vars = v
            elif matched > longest:
                longest = matched
                missing = mis
                if missing == []:
                    pattern = p
                    result = r
                    vars = v

    if debug:
        print("best match for", input, "is", str(longest) + ":", pattern, " missing:", missing)

    return (longest, vars, missing, pattern, result)

class ParseResult():
    def __init__(self):
        self.longest = 0
        self.missing = []
        self.actions = []
        self.new_mode = None
        self.error = None
        self.retval = None

def quote_if_necessary(s):
    if ' ' not in s and '"' not in s: return s
    x = '"'
    for c in s:
        if c == '"': x += '\\"'
        elif c == '\\': x += '\\'
        else: x += c
    x += '"'
    return x

def handle_alias(input, current_mode, include_autoenabled):
    enabled_modes = [current_mode] # important: current_mode comes first
    if include_autoenabled:
        enabled_modes += [m for m in modes if m != current_mode and mode_is_auto_enabled(current_mode, m)]
    patterns = [(pat, (m, exp)) for m in enabled_modes for pat, exp in modes[m].items()]
    r = ParseResult()
    r.new_mode = current_mode

    r.longest, vars, r.missing, pattern, x = \
        longest_matching_pattern(patterns, input, current_mode)

    if r.longest != 0 and r.missing == []:
        m, expansion = x
        original_expansion = expansion
        nvars = [('windowpid', current_windowpid),
                  ('windowtitle', current_windowtitle),
                  ('configdir', configdir),
                  ('*', ' '.join(map(quote_if_necessary, vars[:r.longest])))] + \
                [(str(i), v) for i, v in enumerate(vars)]
        for varname, varvalue in nvars:
            expansion = expansion.replace('"$' + varname + '"', quote_if_necessary(varvalue))
            expansion = expansion.replace('$' + varname, varvalue)
        exp = split_expansion(expansion)

        sub = process(exp, m, True, False)
        if sub.missing == []:
            r.actions = sub.actions
            r.new_mode = sub.new_mode
            r.retval = sub.retval # todo: maybe there are better choices here
        else:
            qexp = list(map(quote_if_necessary, exp))
            s = indented_and_wrapped(
                [colored(s, 'green') + ' ' for s in qexp[:sub.longest]] +
                [colored(s, 'red') + ' ' for s in qexp[sub.longest:]], 4)
            r.error = colored('\nerror:', 'red') + '\n' + \
                '  input ' + colored(' '.join(input[:r.longest]), 'green') + ' matched alias:\n' + \
                '    ' + alias_definition_str(m, pattern, 4) + '\n' + \
                '  invalid expansion:\n    ' + s + '\n' + \
                '  ' + ('missing ' if sub.longest == len(exp) else 'expected ') + \
                ' or '.join(map(italic_types, sub.missing)) + '\n'

    return r

def print_builtin(pattern):
    import inspect
    _, func = builtin_commands[pattern]
    print('\n' + color_commands(pattern), '= ', end='')
    lines = inspect.getsource(func).split('\n')
    while lines != [] and lines[-1] == '':
        lines = lines[:-1]
    if lines != [] and lines[0].startswith('@make_builtin'):
        lines = lines[1:]
    if len(lines) == 1:
        print(lines[0].strip().rstrip(','))
    else:
        print('\n' + '\n'.join(map(lambda s: '    ' + s, lines)), end = '\n\n')

def handle_builtin_command(input, mode, only_global=True):
    patterns = []
    for pat, f in builtin_commands.items():
        if not only_global or is_global_builtin_pattern(pat):
            patterns.append((pat, f))

    r = ParseResult()

    r.longest, vars, r.missing, pattern, x = longest_matching_pattern(patterns, input, mode)
    if r.longest != 0:
        if r.missing == []:
            f, act = x
            if f is not None: r.retval = f(*vars)
            if act is not None: r.actions = [(act, vars)]
            if pattern == 'mode <mode>': r.new_mode = vars[1]
                # this applies the mode switch /during/ command evaluation,
                # which is beyond the capabilities of regular built-ins,
                # since those only produce actions to be executed later.
                # hence this special case for the 'mode' command.

    elif input != []:
        cmd, *args = input
        if cmd == 'builtin':
            r = handle_builtin_command(args, mode, False)
            r.longest += 1 # to account for 'builtin' itself
            return r

    return r

def process(words, mode, handle_builtins=True, include_autoenabled=True):
    if words == []: return ParseResult()
    cmd, *_ = words

    r = handle_alias(words, mode, include_autoenabled)

    if handle_builtins and r.error is None:
        r2 = handle_builtin_command(words, mode)
        if r2.longest > r.longest:
            r.longest = r2.longest
            r.missing = r2.missing
            r.actions = r2.actions
            r.new_mode = r2.new_mode
            r.error = r2.error
            r.retval = r2.retval

    if r.missing != []:
        return r

    if r.longest == 0:
        r.missing = ['<command>']
        r.actions = []
        r.new_mode = mode
    else:
        if r.new_mode is not None:
            mode = r.new_mode

        if r.longest != len(words) and r.error is None:
            r2 = process(words[r.longest:], mode, True, include_autoenabled)
            r.longest += r2.longest
            r.missing = (r2.missing if r2.longest != 0 else ['<command>'])
            r.actions += r2.actions
            r.new_mode = r2.new_mode
            r.error = r2.error
            r.retval = r2.retval

    return r

# input preprocessing:

def replace_numbers(words, collected=''):
    if words == []: return ([collected] if collected != '' else [])
    first, *rest = words
    if first in numbers: return replace_numbers(rest, collected + numbers[first])
    if collected != '': return [collected, first] + replace_numbers(rest)
    return [first] + replace_numbers(rest)

def replace_words(words):
    if words == []: return []
    for i in range(0, len(words)):
        for k, vv in word_replacements.items():
            for v in vv:
                kw = v.split()
                if len(words) >= i + len(kw) and words[i:i+len(kw)] == kw:
                    return words[:i] + k.split() + replace_words(words[i+len(kw):])
    return words

def eval_command(words, line):
    global suggestions
    if words == []: return
    if debug: print()

    handle_builtins = auto_enable_cfg[mode]['built-ins']
    pr = process(words, mode, handle_builtins, True)

    if pr.longest != 0:
        suggestions = []
        if pr.missing != []:
            uu = []
            for m in pr.missing:
                for u in m.split('|'):
                    if u.startswith('<'):
                        type = u[1:-1]
                        if type in completions:
                            cmd = completions[type]
                            suggestions += subprocess.Popen(cmd, shell=True,
                                stdin=subprocess.DEVNULL,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.DEVNULL).stdout.read().decode('utf-8').strip().split('\n')
                    else:
                        suggestions.append(u)

    c = confirm_input(words, pr, line)

    actnames = [' '.join(w) for _, w in pr.actions]
    if actnames != [] and ' '.join(actnames) != ' '.join(words):
        print(', '.join(actnames))

    try:
        for f, w in pr.actions:
            f(*w)
    except Exception as e:
        print(colored(' '.join(w) + ": " + str(e), 'red'))

    if c: clear_line()
    return pr.longest

async def process_lines(input):
    import asyncio
    global mode
    loop = asyncio.get_event_loop()
    reader = asyncio.StreamReader(loop=loop, limit=asyncio.streams._DEFAULT_LIMIT)
    await loop.connect_read_pipe(
        lambda: asyncio.StreamReaderProtocol(reader, loop=loop), input)

    if prompt: print_prompt()
    last_active_modes = get_active_modes(mode)

    successful_input = []

    while True:
        try:
            line = await asyncio.wait_for(reader.readline(), 0.5)
        except asyncio.TimeoutError:
            get_current_application()
            m = get_active_modes(mode)
            if last_active_modes != m:
                last_active_modes = m
                if prompt:
                    clear_line()
                    print_prompt()
        else:
            if not line: break # EOF
            else:
                line = line.decode('utf-8').rstrip('\n')
                if line == '' or line[0] == '#' or line in ignore: continue

                load_config()

                words = replace_numbers(replace_words(line.split()))
                if len(words) > 0 and words[0] in ['the', 'a', 'i', 'and']:
                    words.pop(0)
                if words != []:
                    if words[0] == 'continue': words = successful_input + words[1:]
                    elif len(suggestions) == 1 and words == ['indeed']:
                        words = successful_input + [suggestions[0]]
                    elif suggestions != [] and len(words) == 2 and words[0] == 'indeed' and words[1].isdigit():
                        i = int(words[1])
                        if i < len(suggestions):
                            words = successful_input + [suggestions[i]]
                    longest = eval_command(words, line)
                    if longest != 0:
                        successful_input = words[:longest]
                    if prompt: print_prompt()
                    last_active_modes = get_active_modes(mode)

# output:

def indented_and_wrapped(l, n):
    cols = shutil.get_terminal_size().columns
    cur = n
    r = ''
    l = [x + ' ' for x in ' '.join(l).split()]
    while l != []:
        s = l[0]
        w = len(strip_markup(s))
        if (cur + w <= cols) or r == '' or r.endswith('\n' + ' ' * n):
            cur += w
            r += s
            l = l[1:]
        else:
            r += '\n' + ' ' * n
            cur = n
    return r

def alias_definition_str(mode, pattern, start_column=0):
    expansion = modes[mode][pattern]
    pat = italic_types(pattern)
    r = color_mode(mode) + ' ' + color_commands(pat) + ' = '
    indent = start_column + len(mode) + len(strip_markup(pat)) + len("  = ")
    l = [color_commands(e) + ' ' for e in expansion.split()] # todo: handle '' args
    s = l[-1]; l[-1] = s[:-1] # remove last space
    return r + indented_and_wrapped(l, indent)

def sound(n, count=1, wait=True):
    if count == 0 or not sound_effects: return
    import pygame
    pygame.mixer.music.load("sounds/" + n)
    for i in range(0, count):
        pygame.mixer.music.play()
        if wait:
            while pygame.mixer.music.get_busy(): time.sleep(0.01)
            time.sleep(0.1)

def short_mode_name(mode):
    return (short_mode_names[mode] if mode in short_mode_names else mode)

def clear_line():
    if not sys.stdout.isatty() or not prompt: return
    cols = shutil.get_terminal_size().columns
    print('\r' + ' ' * cols + '\r', end='')
    sys.stdout.flush()

def prompt_string():
    current, *auto = get_active_modes(mode)
    short_current = short_mode_name(current)
    mm = []
    if short_current != '': mm = [short_current]
    elif auto != []: mm = [current]
    mm += [s for s in list(map(short_mode_name, auto)) if s != '']
    return ','.join(map(color_mode, mm)) + '> '

def print_prompt():
    print(prompt_string(), end='')
    sys.stdout.flush()

def truncate(s, n):
    return (s[:n-3] + '...' if len(s) > n else s)

def confirm_input(words, pr, original_input):
    n = pr.longest
    cols = shutil.get_terminal_size().columns
    prp = prompt_string()
    printed = ''
    if n == 0 or (n == 1 and pr.missing != [] and words[0].isdigit()):
        clear_line()
        print(prp + colored(truncate(original_input, cols - len(strip_markup(prp))), 'yellow'), end='\r')
        sys.stdout.flush()
        return False
    if prompt:
        clear_line()
        printed = prp + colored(' '.join(words[:n]), 'green')
        print(printed, end='')
    if pr.error is not None:
        print(pr.error)
        sound('good.wav', n)
        sound('bad.wav', 1, wait=False)
        return False

    if prompt:
        if n != len(words):
            if n != 0:
                print(' ', end='')
                printed += ' '
            avail = cols - len(strip_markup(printed))
            print(colored(truncate(' '.join(words[n:]), avail), 'red'), end='')
        elif pr.missing != []:
            # if all words were consumed but evaluation still went bad,
            # it means additional input was missing
            print(colored(' ???', 'red'), end='')
        print()

    if pr.missing == []:
        if pr.retval is not None:
            print(colored(str(pr.retval), 'magenta'))
    else:
        if suggestions != []:
            if len(suggestions) == 1 and not suggestions[0].startswith('<'):
                print(colored("error: did you mean '" + suggestions[0] + "'?", 'red'))
            else:
                print(colored("did you perhaps mean:", 'red'))
                rows = shutil.get_terminal_size().lines
                for i, s in enumerate(suggestions[:rows - 3]):
                    print('-', s + '?', '(' + str(i) + ')')
        else:
            what = ' or '.join(map(italic_types, list(set(pr.missing))))
            problem = ('missing' if n == len(words) else 'expected')
            print(colored('error: ' + problem + ' ' + what, 'red'))

    sound('good.wav', n)
    if n != len(words) or pr.missing != []:
        sound('bad.wav', 1, wait=False)
    return True

def simple_subprocess(cmd):
    p = subprocess.Popen(cmd, shell=True,
        stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return p.stdout.read().decode('utf-8').rstrip()

def print_pstree(t, indent=0):
    if 'name' in t:
        print(t['name'])
    else:
        print('?')
    for k, v in t.items():
        if k != 'name':
            print(' ' * indent + '- ', end='')
            print_pstree(v, indent + 2)

def get_current_application():
    global current_windowtitle, current_windowpid, current_windowprocesses
    current_windowpid = ''
    current_windowtitle = ''
    current_windowprocesses = {}
    active_win = simple_subprocess('xdotool getactivewindow')
    if active_win == '': return
    current_windowtitle = simple_subprocess('xdotool getwindowname ' + active_win)
    current_windowpid = simple_subprocess('xdotool getwindowpid ' + active_win)
    if current_windowpid != '':
        current_windowprocesses = process_family(int(current_windowpid))

ERROR_HANDLER_FUNC = CFUNCTYPE(None, c_char_p, c_int, c_char_p, c_int, c_char_p)

def py_asound_error_handler(filename, line, function, err, fmt):
    pass

c_asound_error_handler = ERROR_HANDLER_FUNC(py_asound_error_handler)

@contextmanager
def noalsaerr():
    if sound_effects:
        asound = cdll.LoadLibrary('libasound.so')
        asound.snd_lib_error_set_handler(c_asound_error_handler)
    yield
    if sound_effects:
        asound.snd_lib_error_set_handler(None)

@contextmanager
def hidden_cursor():
    if sys.stdout.isatty() and prompt:
        print()
        sys.stdout.write("\033[?25l") # hide cursor
    try:
        yield
    finally:
        if sys.stdout.isatty() and prompt:
            sys.stdout.write("\033[?25h") # restore cursor

@click.command()
@click.option('--debug', default=False,type=bool, is_flag=True)
@click.option('--color', default=True,type=bool)
@click.option('--prompt', default=True,type=bool)
@click.option('--configdir', default=os.getenv('HOME') + '/.evc-voice-commander',type=str)
@click.option('--dryrun', default=False, type=bool, is_flag=True)
@click.option('--volume', default=0.1, type=float) # default volume very low so our beeps are
                                                   # (a) non-obnoxious, and
                                                   # (b) won't interfere with speech recognition.
@click.argument('mode', nargs=1, default='default')
@click.argument('cmd', nargs=-1)
def evc(debug, color, prompt, configdir, dryrun, volume, mode, cmd):
    global sound_effects, explicitly_autoenabled

    mm = mode.split(',')
    explicitly_autoenabled = mm[1:]
    mode = mm[0]

    globals()['mode'] = mode
    globals()['color'] = color
    globals()['configdir'] = configdir
    globals()['dryrun'] = dryrun
    globals()['debug'] = debug
    globals()['prompt'] = prompt
    initial_words = list(cmd)
    if volume != 0:
        import pygame
        pygame.init()
        pygame.mixer.music.set_volume(volume)
        sound_effects = True

    load_config()

    if mode not in modes:
        print("no such mode:", mode)
        return

    with noalsaerr():
        with hidden_cursor():
            if initial_words != []:
                eval_command(initial_words, ' '.join(initial_words))
            else:
                import asyncio
                asyncio.get_event_loop().run_until_complete(process_lines(sys.stdin))

if __name__ == '__main__': evc()
