#!/usr/bin/env python3

import os
import subprocess
import sys
import re
import itertools
import time
import fileinput
import pyautogui # better than pynput because pynput doesn't let you send mod+letter
import yaml
import collections
import psutil
import asyncio
import shutil
import inspect
from termcolor import colored
from ctypes import *
from contextlib import contextmanager
import click

os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "hide"
import pygame # apt-get install python-pygame

sound_effects = True
idle_mode = 'stopped'
mode = idle_mode
modes = {idle_mode:{}}
numbers = {}
word_replacements = {}
enums = {}
ignore = ["i", "of", "the", "if"]
current_windowpid = ''
current_windowtitle = ''
current_windowprocesses = {}
debug = False

extra_key_names = {
    'space': ' ',
    'dollar': '$',
    'ampersand': '&',
    'hash': '#',
    'percent': '%',
    'period': '.',
    'comma': ',',
    'slash': '/',
    'wmkey': 'winleft'
}

short_mode_names = {}

configdir = os.getenv('HOME') + '/.evc-voice-controller'

auto_enable_for_applications = {}
auto_enable_for_leaf_applications = {}
auto_enable_for_suffixes = {}
auto_enable_for_prefixes = {}

global_builtins = ['stop', 'options', 'define', 'builtin', 'times']
    # this order is also used for display to humans

def load_config():
    global word_replacements, numbers, modes, enums, short_mode_names
    global auto_enable_for_applications
    global auto_enable_for_leaf_applications
    global auto_enable_for_suffixes
    global auto_enable_for_prefixes
    short_mode_names = {}
    auto_enable_for_applications = {}
    auto_enable_for_leaf_applications = {}
    auto_enable_for_suffixes = {}
    auto_enable_for_prefixes = {}
    try:
        with open(configdir + '/replacements.yaml', 'r') as stream:
            word_replacements = yaml.safe_load(stream)
        with open(configdir + '/numbers.yaml', 'r') as stream:
            numbers = yaml.safe_load(stream)
        with open(configdir + '/modes.yaml', 'r') as stream:
            modes = yaml.safe_load(stream)

        # handle enums:
        enums = {}
        for key, v in modes.items():
            if key.startswith('<'):
                n = key[1:-1]
                if type(v) is list: v = '/'.join(v)
                enums[n] = v
        for e in enums:
            del modes['<' + e + '>']

        # handle shortnames:
        def remove_shortname(s):
            i = s.find('(')
            return (s if i == -1 else s[:i].strip())
        for mode, aliases in modes.items():
            realname = remove_shortname(mode)
            if realname != mode:
                shortname = mode[mode.find('(') + 1: -1]
                short_mode_names[realname] = shortname
        modes = dict([(remove_shortname(m), a) for m, a in modes.items()])

        # handle auto-enabling:
        for mode, aliases in modes.items():
            if 'auto-enable-for-applications' in aliases:
                auto_enable_for_applications[mode] = aliases['auto-enable-for-applications'].split()
                del aliases['auto-enable-for-applications']
            if 'auto-enable-for-leaf-applications' in aliases:
                auto_enable_for_leaf_applications[mode] = aliases['auto-enable-for-leaf-applications'].split()
                del aliases['auto-enable-for-leaf-applications']
            if 'auto-enable-for-prefixes' in aliases:
                auto_enable_for_prefixes[mode] = aliases['auto-enable-for-prefixes']
                del aliases['auto-enable-for-prefixes']
            if 'auto-enable-for-suffixes' in aliases:
                auto_enable_for_suffixes[mode] = aliases['auto-enable-for-suffixes']
                del aliases['auto-enable-for-suffixes']

    except Exception as e:
        print("\nerror loading config:", e)

def key_by_name(name):
    return (extra_key_names[name] if name in extra_key_names else name)

# built-in commands:

def is_global_builtin_pattern(pat):
    pat = pat.split()
    while pat != [] and pat[0][0] == '<':
        pat = pat[1:]
    return pat != [] and pat[0] in global_builtins

def is_keyname(s):
    return s in pyautogui.KEYBOARD_KEYS or s in extra_key_names

def is_keyspec(spec):
    all_keys = pyautogui.KEYBOARD_KEYS + list(extra_key_names.keys())
    for combo in spec.split(','):
        mult = combo.find('*')
        if mult != -1:
            if not combo[:mult].isdigit(): return False
            combo = combo[mult+1:]
        for k in combo.split('+'):
            if not is_keyname(k): return False
    return True

builtin_commands = {}

def make_builtin(pattern):
    def f(g):
        builtin_commands[pattern] = (None, g)
        return g
    return f

def make_functional_builtin(pattern):
    def f(g):
        builtin_commands[pattern] = (g, None)
        return g
    return f

def action(cmd, mode):
    pr = process(list(cmd), mode)
    def combined():
        for f, w in pr.actions: f(*w)
    return combined

@make_builtin('<number> times <command>')
def num_times_cmd(n, _, *cmd):
    a = action(cmd, mode)
    for i in range(int(n)): a()

@make_builtin('run <word>')
def cmd_run(_, cmd):
    subprocess.Popen(cmd, shell=True,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)

@make_builtin('execute <word>')
def cmd_execute(_, cmd):
    output = subprocess.Popen(cmd, shell=True,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE).stdout.read().decode('utf-8').strip()
    cmd_print('print', output)

@make_builtin('restart')
def cmd_restart(_):
    os.execl(sys.argv[0], *sys.argv)

@make_builtin('keydown <key>')
def press_key(_, key_name):
    pyautogui.keyDown(key_by_name(key_name))

@make_builtin('keyup <key>')
def release_key(_, key_name):
    pyautogui.keyUp(key_by_name(key_name))

@make_builtin('nop')
def cmd_nop(_):
    pass

@make_builtin('shutdown')
def cmd_exit(_):
    sys.stdout.write("\033[?25h") # restore cursor
    sys.exit(0)

@make_functional_builtin('<number> plus <number>')
def cmd_plus(x, _p, y):
    return int(x) + int(y)

@make_functional_builtin('<number> minus <number>')
def cmd_minus(x, _p, y):
    return int(x) - int(y)

@make_functional_builtin('<number> times <number>')
def num_times_num(x, _p, y):
    return int(x) * int(y)

@make_functional_builtin('enumindex <word> <word>')
def cmd_enumindex(_, e, v):
    l = enums[e].split('/')
    return l.index(v) if v in l else -1

# times and overloading

@make_builtin('define <command>')
def cmd_define(_, *cmd):

    for m in [mode] + [m for m in modes if m != mode and mode_is_auto_enabled(m)]:
        for pattern in modes[m].keys():
            matched, missing, _ = params_matched(pattern.split(), list(cmd), mode)
            if matched > 0 and missing == []:
                print('\nin ', end='')
                print(alias_definition_str(m, pattern, len('in ')))
                print()
                return
    for pattern, _ in builtin_commands.items():
        matched, missing, _ = params_matched(pattern.split(), list(cmd), mode)
        if matched > 0 and missing == []:
            print_builtin(pattern)

ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
def strip_markup(s):
    return ansi_escape.sub('', s)

turn_on_italic = "\x1B[3m"
turn_off_italic = "\x1B[23m"

def italic_types(pattern):
    return '/'.join(
            [' '.join(
                ['|'.join(
                    [ (turn_on_italic + alt[1:-1] + turn_off_italic if alt.startswith('<') else alt)
                        for alt in param.split('|')
                    ])
                    for param in form.split(' ')
                ])
                for form in pattern.split('/')])

@make_builtin('options')
def cmd_options(_):
    mm = [mode]
    if mode != idle_mode:
        mm += [m for m in modes if m != mode and mode_is_auto_enabled(m)]
    print()
    builtins_displayed = []

    def command_pattern(pat):
        return color_commands(italic_types(pat)) + ', '

    def simple_pattern(pat):
        return italic_types(pat) + ', '

    for m in mm:
        indent = len(m) + len("in : ")
        l = []
        simples = []
        for pat, exp in modes[m].items():
            if exp == 'builtin $*':
                for form in pat.split('/'):
                    simples.append(simple_pattern(form))
            elif exp == 'builtin press $0':
                if len(pat.split()) == 1:
                    for alt in pat.split('|'):
                        simples.append(simple_pattern(alt))
                else:
                    simples.append(simple_pattern(pat))
            else:
                l.append(command_pattern(pat))
        l += simples
        for pat, exp in modes[m].items():
            if pat in modes and pat != m and exp == 'builtin mode ' + pat:
                l.append(color_mode(pat) + ', ')
        if l != []:
            print('in', color_mode(m) + ': ', end='')
            s = l[-1]; l[-1] = s[:-2] # remove last comma
            print(indented_and_wrapped(l, indent), end='\n\n')

    l = [italic_types(b) + ', ' for b in builtin_commands.keys() if is_global_builtin_pattern(b)]
    if l != []:
        print('global: ', end='')
        indent = len('global: ')
        s = l[-1]; l[-1] = s[:-2] # remove last comma
        print(indented_and_wrapped(l, indent), end='\n\n')

@make_builtin('text <word>')
def cmd_text(_, s):
    pyautogui.press([c for c in s])

@make_builtin('mode <mode>')
def cmd_mode(_, new_mode):
    global mode
    mode = new_mode

@make_builtin('return <word>')
def cmd_return(_, _w):
    pass

@make_builtin('press <keys>')
def cmd_press(_, spec):
    for combo in spec.split(','):
        times = 1
        mult = combo.find('*')
        if mult != -1:
            times = int(combo[:mult])
            combo = combo[mult+1:]
        keys = combo.split('+')
        if len(keys) == 1:
            k = key_by_name(keys[0])
            pyautogui.press([k] * times)
        else:
            for i in range(times):
                for k in keys: press_key('press', k)
                time.sleep(0.05)
                for k in reversed(keys): release_key('release', k)

@make_builtin('print <word>')
def cmd_print(_, s):
    print(colored(s, 'magenta'))

# command evaluation:

builtin_types = {
    'word': lambda _: True,
    'number': lambda s: s.isdigit(),
    'key': is_keyname,
    'keys': is_keyspec,
    'mode':
        lambda m: m in modes.keys()
}

def param_matched(param, args, mode):
    arg = args[0]
    for alt in param.split('|'):
        if alt == arg: return (1, [])
        for type, pred in builtin_types.items():
            if alt == '<' + type + '>' and pred(arg):
                return (1, [])
        for e in enums:
            if alt == '<' + e + '>':
                alternatives = enums[e].split('/')
                for a in alternatives:
                    params = a.split()
                    if [arg] == params:
                        return (1, [])
                    matched, _v, mis, _pat, _r = longest_matching_pattern([(a, None)], args, mode)
                    if matched != 0: # todo: find longest, but let's get rid of enumindex hack first
                        return (matched, mis)
    return (0, [param])

def params_matched(params, args, mode, i = 0):
    vars = []
    args_matched = 0
    missing = []
    while i < len(params):
        if args == []:
            break

        varieties = []

        if args[:1] == ['evaluate']:
            sub = args[1:]
            pr = process(sub, mode, True, True)
            varieties.append((pr.longest, pr.missing, [str(pr.retval)] + sub[pr.longest:], [], i))
                # not i+1 because still on same parameter
                # we would need to add 1 to pr.longest to account for having consumed 'evaluate',
                # but this is canceled out by a -1 to account for the newly inserted argument.

        if params[i] == '<command>':
            pr = process(args, mode, True, True)
            varieties.append((pr.longest, pr.missing, args[pr.longest:], args[:pr.longest], i + 1))

        am, miss = param_matched(params[i], args, mode)
        varieties.append((am, miss, args[am:], [' '.join(args[:am])], i + 1))

        longest_here = 0
        vars_here = []

        for n, mis, a, v, ni in varieties:
            if n == longest_here:
                if mis == [] and missing != []:
                    missing = []
                    args = a
                    vars_here = v
                    i = ni
                else:
                    missing += mis
            elif n > longest_here:
                longest_here = n
                missing = mis
                args = a
                vars_here = v
                i = ni

        vars += vars_here
        args_matched += longest_here

        if missing != []: # or i is None:
            break

    if i < len(params) and missing == []:
        missing = [params[i]]
    return (args_matched, missing, vars)

def pstree_branch(pids, names, children):
    r = {}
    for pid in pids:
        name = (names[pid] if pid in names else '?')
        b = (pstree_branch(children[pid], names, children) if pid in children else {})
        b['name'] = name
        r[pid] = b
    return r

def process_family(pid):
    children = collections.defaultdict(list)
    names = {}
    for p in psutil.process_iter():
        try:
            children[p.ppid()].append(p.pid)
            names[p.pid] = p.name()
        except (psutil.NoSuchProcess, psutil.ZombieProcess):
            pass
    start = [pid]
    return pstree_branch(start, names, children)

def occurs_in_branch(x, processes):
    for k, v in processes.items():
        if k == 'name':
            if v == x: return True
        elif occurs_in_branch(x, v):
            return True
    return False

def occurs_as_leaf_in_branch(x, processes):
    if len(processes) == 1 and 'name' in processes and processes['name'] == x:
        return True
    for k, v in processes.items():
        if k != 'name' and occurs_as_leaf_in_branch(x, v):
            return True
    return False

def mode_is_auto_enabled(m):
    if m == idle_mode: return True
    if m in auto_enable_for_applications:
        for app in auto_enable_for_applications[m]:
            if occurs_in_branch(app, current_windowprocesses):
                return True
    if m in auto_enable_for_leaf_applications:
        for app in auto_enable_for_leaf_applications[m]:
            if occurs_as_leaf_in_branch(app, current_windowprocesses):
                return True
    if m in auto_enable_for_prefixes:
        for prefix in auto_enable_for_prefixes[m]:
            if current_windowtitle.startswith(prefix):
                return True
    if m in auto_enable_for_suffixes:
        for suffix in auto_enable_for_suffixes[m]:
            if current_windowtitle.endswith(suffix):
                return True
    return False

def get_active_modes(mode):
    if mode == idle_mode: return [mode]
    return [m for m in modes if m == mode or mode_is_auto_enabled(m)]

def color_commands(p):
    return colored(p, 'magenta')

def color_mode(m):
    return colored(m, 'cyan')

def split_expansion(s):
    if s == '': return []
    if s[0] == '"':
        close = s[1:].find('"') + 1
        # todo: handle close == -1
        x = s[1:close]
        if close+1 == len(s): return [x]
        # todo: handle s[close+1]!=' '
        afterspace = close+1
        while s[afterspace] == ' ': afterspace += 1
        return [x] + split_expansion(s[afterspace:])
    space = s.find(' ')
    if space == -1: return [s]
    afterspace = space + 1
    while afterspace < len(s) and s[afterspace] == ' ': afterspace += 1
    return [s[:space]] + split_expansion(s[afterspace:])

def longest_matching_pattern(patterns, input, mode):
    # if multiple patterns match equally well, the first one of them is returned
    # (this is important because it's how commands in the current mode
    #  override commands in auto-enabled modes)

    longest = 0
    vars = None
    missing = []
    pattern = None
    result = None

    if debug:
        print("finding longest pattern matching", input, "among", [p for p, _ in patterns])

    for p, r in patterns:
        for form in p.split('/'):
            params = form.split()
            matched, mis, v = params_matched(params, input, mode)
            if matched == longest and mis == []:
                missing = []
                pattern = p
                result = r
                vars = v
            elif matched == longest and mis != []:
                missing += mis
            elif matched > longest:
                longest = matched
                missing = mis
                if missing == []:
                    pattern = p
                    result = r
                    vars = v

    if debug:
        print("best match for", input, "is", str(longest) + ":", pattern, " missing:", missing)

    return (longest, vars, missing, pattern, result)

class ParseResult():
    def __init__(self):
        self.longest = 0
        self.missing = []
        self.actions = []
        self.new_mode = None
        self.error = None
        self.retval = None

def quote_if_necessary(s):
    return (s if ' ' not in s else '"' + s + '"')

def handle_alias(input, current_mode, include_autoenabled):
    enabled_modes = [current_mode]
    if include_autoenabled and current_mode != idle_mode:
        enabled_modes += [m for m in modes if m != current_mode and mode_is_auto_enabled(m)]

    patterns = [(pat, (m, exp)) for m in enabled_modes for pat, exp in modes[m].items()]

    r = ParseResult()
    r.new_mode = current_mode

    r.longest, vars, r.missing, pattern, x = \
        longest_matching_pattern(patterns, input, current_mode)

    if r.longest != 0 and r.missing == []:
        m, expansion = x
        original_expansion = expansion
        nvars = [('windowpid', current_windowpid),
                  ('windowtitle', current_windowtitle),
                  ('*', ' '.join(input[:r.longest]))] + \
                [(str(i), v) for i, v in enumerate(vars)]
        for varname, varvalue in nvars:
            expansion = expansion.replace('$' + varname, varvalue)
        exp = split_expansion(expansion)

        sub = process(exp, m, True, False)
        if sub.missing == []:
            r.actions = sub.actions
            r.new_mode = sub.new_mode
            r.retval = sub.retval # todo: maybe there are better choices here
        else:
            qexp = list(map(quote_if_necessary, exp))
            s = indented_and_wrapped(
                [colored(s, 'green') + ' ' for s in qexp[:sub.longest]] +
                [colored(s, 'red') + ' ' for s in qexp[sub.longest:]], 4)
            r.error = colored('\nerror:', 'red') + '\n' + \
                '  input ' + colored(' '.join(input), 'green') + ' matched alias:\n' + \
                '    ' + alias_definition_str(m, pattern, 4) + '\n' + \
                '  invalid expansion:\n    ' + s + '\n' + \
                '  ' + ('missing ' if sub.longest == len(exp) else 'expected ') + \
                ' or '.join(map(italic_types, sub.missing)) + '\n'

    return r

def print_builtin(pattern):
    _, func = builtin_commands[pattern]
    print('\n' + color_commands(pattern), '= ', end='')
    lines = inspect.getsource(func).split('\n')
    while lines != [] and lines[-1] == '':
        lines = lines[:-1]
    if lines != [] and lines[0].startswith('@make_builtin'):
        lines = lines[1:]
    if len(lines) == 1:
        print(lines[0].strip().rstrip(','))
    else:
        print('\n' + '\n'.join(map(lambda s: '    ' + s, lines)), end = '\n\n')

def handle_builtin_command(input, mode, only_global=True):
    patterns = []
    for pat, f in builtin_commands.items():
        if not only_global or is_global_builtin_pattern(pat):
            patterns.append((pat, f))

    r = ParseResult()

    r.longest, vars, r.missing, pattern, x = longest_matching_pattern(patterns, input, mode)
    if r.longest != 0:
        if r.missing == []:
            f, act = x
            if f is not None: r.retval = f(*vars)
            if act is not None: r.actions = [(act, vars)]
            if pattern == 'mode <mode>': r.new_mode = input[1]
                # this applies the mode switch /during/ command evaluation,
                # which is beyond the capabilities of regular built-ins,
                # since those only produce actions to be executed later.
                # hence this special case for the 'mode' command.
            if pattern == "return <word>": r.retval = input[1]

    elif input != []:
        cmd, *args = input
        if cmd == 'builtin':
            r = handle_builtin_command(args, mode, False)
            r.longest += 1 # to account for 'builtin' itself
            return r

    return r

def process(words, mode, handle_builtins=True, include_autoenabled=True):
    if words == []: return ParseResult()
    cmd, *_ = words

    r = handle_alias(words, mode, include_autoenabled)

    if handle_builtins and r.error is None:
        r2 = handle_builtin_command(words, mode)
        if r2.longest > r.longest:
            r.longest = r2.longest
            r.missing = r2.missing
            r.actions = r2.actions
            r.new_mode = r2.new_mode
            r.error = r2.error
            r.retval = r2.retval

    if r.missing != []:
        return r

    if r.longest == 0:
        r.missing = ['<command>']
        r.actions = []
        r.new_mode = mode
    else:
        if r.new_mode is not None:
            mode = r.new_mode

        if r.longest != len(words) and r.error is None:
            r2 = process(words[r.longest:], mode, True, include_autoenabled)
            r.longest += r2.longest
            r.missing = (r2.missing if r2.longest != 0 else ['<command>'])
            r.actions += r2.actions
            r.new_mode = r2.new_mode
            r.error = r2.error
            r.retval = r2.retval

    return r

# input preprocessing:

def replace_numbers(words, collected=''):
    if words == []: return ([collected] if collected != '' else [])
    first, *rest = words
    if first in numbers: return replace_numbers(rest, collected + numbers[first])
    if collected != '': return [collected, first] + replace_numbers(rest)
    return [first] + replace_numbers(rest)

def replace_words(words):
    if words == []: return []
    for i in range(0, len(words)):
        for k, vv in word_replacements.items():
            for v in vv:
                kw = v.split()
                if len(words) >= i + len(kw) and words[i:i+len(kw)] == kw:
                    return words[:i] + k.split() + replace_words(words[i+len(kw):])
    return words

def eval_command(words, line):
    if words == []: return
    if debug: print()

    handle_builtins = (mode != idle_mode)
    pr = process(words, mode, handle_builtins, True)

    c = confirm_input(words, pr, line)
    actnames = [' '.join(w) for _, w in pr.actions]
    if actnames != [] and ' '.join(actnames) != ' '.join(words):
        print(', '.join(actnames))
    for f, w in pr.actions:
        f(*w)
    if c: clear_line()
    print_prompt()

async def process_lines(input):
    global mode
    loop = asyncio.get_event_loop()
    reader = asyncio.StreamReader(loop=loop, limit=asyncio.streams._DEFAULT_LIMIT)
    await loop.connect_read_pipe(
        lambda: asyncio.StreamReaderProtocol(reader, loop=loop), input)

    print_prompt()
    last_active_modes = get_active_modes(mode)

    while True:
        try:
            line = await asyncio.wait_for(reader.readline(), 0.5)
        except asyncio.TimeoutError:
            get_current_application()
            m = get_active_modes(mode)
            if last_active_modes != m:
                last_active_modes = m
                clear_line()
                print_prompt()
        else:
            if not line: break # EOF
            else:
                line = line.decode('utf-8').rstrip('\n')
                if line == '' or line[0] == '#' or line in ignore: continue

                load_config()

                words = replace_numbers(replace_words(line.split()))
                if len(words) > 0 and words[0] in ['the', 'a', 'i', 'and']:
                    words.pop(0)
                if words != []:
                    eval_command(words, line)
                    last_active_modes = get_active_modes(mode)

# output:

def indented_and_wrapped(l, n):
    cols = shutil.get_terminal_size().columns
    cur = n
    r = ''
    l = [x + ' ' for x in ' '.join(l).split()]
    while l != []:
        s = l[0]
        w = len(strip_markup(s))
        if (cur + w <= cols) or r == '' or r.endswith('\n' + ' ' * n):
            cur += w
            r += s
            l = l[1:]
        else:
            r += '\n' + ' ' * n
            cur = n
    return r

def alias_definition_str(mode, pattern, start_column=0):
    expansion = modes[mode][pattern]
    pat = italic_types(pattern)
    r = color_mode(mode) + ' ' + color_commands(pat) + ' = '
    indent = start_column + len(mode) + len(strip_markup(pat)) + len("  = ")
    l = [color_commands(e) + ' ' for e in expansion.split()] # todo: handle '' args
    s = l[-1]; l[-1] = s[:-1] # remove last space
    return r + indented_and_wrapped(l, indent)

def sound(n, count=1, wait=True):
    if count == 0 or not sound_effects: return
    pygame.mixer.music.load("sounds/" + n)
    for i in range(0, count):
        pygame.mixer.music.play()
        if wait:
            while pygame.mixer.music.get_busy(): time.sleep(0.01)
            time.sleep(0.1)

def short_mode_name(mode):
    return (short_mode_names[mode] if mode in short_mode_names else mode)

def clear_line():
    cols = shutil.get_terminal_size().columns
    print('\r' + ' ' * cols + '\r', end='')
    sys.stdout.flush()

def prompt_string():
    mm = list(map(short_mode_name, get_active_modes(mode)))
    if '' in mm: mm.remove('')
    return ','.join(map(color_mode, mm)) + '> '

def print_prompt():
    print(prompt_string(), end='')
    sys.stdout.flush()

def truncate(s, n):
    return (s[:n-3] + '...' if len(s) > n else s)

def confirm_input(words, pr, original_input):
    n = pr.longest
    if n == 0 or (n == 1 and pr.missing != [] and words[0].isdigit()):
        clear_line()
        prp = prompt_string()
        cols = shutil.get_terminal_size().columns
        print(prp, end='')
        print(colored(truncate(original_input, cols - len(strip_markup(prp))), 'yellow'), end='\r')
        sys.stdout.flush()
        return False
    clear_line()
    print_prompt()
    print(colored(' '.join(words[:n]), 'green'), end='')
    if pr.error is not None:
        print(pr.error)
        sound('good.wav', n)
        sound('bad.wav', 1, wait=False)
        return False

    if n != len(words):
        if n != 0: print(' ', end='')
        print(colored(' '.join(words[n:]), 'red'), end='')
    elif pr.missing != []:
        # if all words were consumed but evaluation still went bad,
        # it means additional input was missing
        print(colored(' ???', 'red'), end='')
    print()

    if pr.missing == []:
        if pr.retval is not None:
            print(colored(str(pr.retval), 'magenta'))
    else:
        what = ' or '.join(map(italic_types, pr.missing))
        problem = ('missing' if n == len(words) else 'expected')
        print(colored('error: ' + problem + ' ' + what, 'red'))

    sound('good.wav', n)
    if n != len(words) or pr.missing != []:
        sound('bad.wav', 1, wait=False)
    return True

def simple_subprocess(cmd):
    p = subprocess.Popen(cmd, shell=True,
        stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return p.stdout.read().decode('utf-8').rstrip()

def get_current_application():
    global current_windowtitle, current_windowpid, current_windowprocesses
    current_windowpid = ''
    current_windowtitle = ''
    current_windowprocesses = {}
    active_win = simple_subprocess('xdotool getactivewindow')
    if active_win == '': return
    current_windowtitle = simple_subprocess('xdotool getwindowname ' + active_win)
    current_windowpid = simple_subprocess('xdotool getwindowpid ' + active_win)
    if current_windowpid != '':
        current_windowprocesses = process_family(int(current_windowpid))

ERROR_HANDLER_FUNC = CFUNCTYPE(None, c_char_p, c_int, c_char_p, c_int, c_char_p)

def py_asound_error_handler(filename, line, function, err, fmt):
    pass

c_asound_error_handler = ERROR_HANDLER_FUNC(py_asound_error_handler)

@contextmanager
def noalsaerr():
    asound = cdll.LoadLibrary('libasound.so')
    asound.snd_lib_error_set_handler(c_asound_error_handler)
    yield
    asound.snd_lib_error_set_handler(None)

@click.command()
@click.option('--debug', default=False,type=bool)
@click.option('--volume', default=0.1, type=float) # default volume very low so our beeps are
                                                   # (a) non-obnoxious, and
                                                   # (b) won't interfere with speech recognition.
@click.argument('mode', nargs=1, default=idle_mode)
@click.argument('cmd', nargs=-1)
def evc(debug, volume, mode, cmd):
    globals()['mode'] = mode
    globals()['debug'] = debug
    initial_words = list(cmd)
    pygame.init()
    pygame.mixer.music.set_volume(volume)

    sys.stdout.write("\033[?25l") # hide cursor:

    load_config()

    print()

    with noalsaerr():
        if initial_words != []:
            eval_command(initial_words, ' '.join(initial_words))
        else:
            asyncio.get_event_loop().run_until_complete(process_lines(sys.stdin))

    sys.stdout.write("\033[?25h") # restore cursor

if __name__ == '__main__': evc()
