#!/usr/bin/env python3

import os
import subprocess
import sys
import itertools
import time
import fileinput
import pyautogui # better than pynput because pynput doesn't let you send mod+letter
import yaml
import psutil
import asyncio
import shutil
from termcolor import colored

os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "hide"
import pygame # apt-get install python-pygame

sound_effects = True
idle_mode = 'stopped'
mode = idle_mode
modes = {idle_mode:{}}
numbers = {}
word_replacements = {}
enums = {}
ignore = ["i", "of", "the", "if"]
current_application = ''
current_windowtitle = ''

extra_key_names = {
    'space': ' ',
    'wmkey': 'winleft'
}

short_mode_names = {}

configdir = os.getenv('HOME') + '/.evc-voice-controller'

auto_enable_for_applications = {}
auto_enable_for_suffixes = {}
auto_enable_for_prefixes = {}


def mode_is_auto_enabled(m):
    global current_application, current_windowtitle
    aliases = modes[m]
    if ('auto-enable-for-applications' in aliases and
      current_application in aliases['auto-enable-for-applications'].split()):
        return True
    if 'auto-enable-for-prefixes' in aliases:
        for prefix in aliases['auto-enable-for-prefixes']:
            if current_windowtitle.startswith(prefix):
                return True
    if 'auto-enable-for-suffixes' in aliases:
        for suffix in aliases['auto-enable-for-suffixes']:
            if current_windowtitle.endswith(suffix):
                return True
    return False
def load_config():
    global word_replacements, numbers, modes, enums, short_mode_names
    global auto_enable_for_applications
    global auto_enable_for_suffixes
    global auto_enable_for_prefixes
    short_mode_names = {}
    auto_enable_for_applications = {}
    auto_enable_for_suffixes = {}
    auto_enable_for_prefixes = {}
    try:
        with open(configdir + '/replacements.yaml', 'r') as stream:
            word_replacements = yaml.safe_load(stream)
        with open(configdir + '/numbers.yaml', 'r') as stream:
            numbers = yaml.safe_load(stream)
        with open(configdir + '/modes.yaml', 'r') as stream:
            modes = yaml.safe_load(stream)
        with open(configdir + '/enums.yaml', 'r') as stream:
            enums = yaml.safe_load(stream)
    except Exception as e:
        print("Error loading config:", e)
        return

    for mode, aliases in modes.items():
        if 'redirect-modes' in aliases:
            for m in aliases['redirect-modes'].split():
                aliases[m] = 'switch ' + m
            del aliases['redirect-modes']
        if 'forward-keys' in aliases:
            for key in aliases['forward-keys'].split():
                isenum = False
                for enumname, enumerators in enums.items():
                    if key == '<' + enumname + '>':
                        isenum = True
                        for key in enumerators.split():
                            aliases[key] = 'press ' + key
                if not isenum: aliases[key] = 'press ' + key
            del aliases['forward-keys']
        if 'short-name' in aliases:
            short_mode_names[mode] = aliases['short-name']
            del aliases['short-name']
        if 'auto-enable-for-applications' in aliases:
            auto_enable_for_applications[mode] = aliases['auto-enable-for-applications'].split()
            del aliases['auto-enable-for-applications']
        if 'auto-enable-for-prefixes' in aliases:
            auto_enable_for_prefixes[mode] = aliases['auto-enable-for-prefixes']
            del aliases['auto-enable-for-prefixes']
        if 'auto-enable-for-suffixes' in aliases:
            auto_enable_for_suffixes[mode] = aliases['auto-enable-for-suffixes']
            del aliases['auto-enable-for-suffixes']

def key_by_name(name):
    return (extra_key_names[name] if name in extra_key_names else name)

# built-in commands:

def switch_mode(new_mode):
    global mode
    mode = new_mode

def press_key(key_name):
    pyautogui.keyDown(key_by_name(key_name))

def release_key(key_name):
    pyautogui.keyUp(key_by_name(key_name))

def cmd_text(s):
    pyautogui.press([c for c in s])

def indented_and_wrapped(l, n):
    cols = shutil.get_terminal_size().columns
    cur = n
    r = ''
    while l != []:
        (s, w) = l[0]
        if cur + w <= cols:
            cur += w
            r += s
            l = l[1:]
        else:
            r += '\n' + ' ' * n
            cur = n
    return r

def cmd_options():
    mm = [mode]
    if mode != idle_mode:
        mm += [m for m in modes if m != mode and mode_is_auto_enabled(m)]
    print()
    for m in mm:
        print('in', color_mode(m) + ': ', end='')
        indent = len(m) + len("in : ")
        l = [(color_commands(c) + ', ', len(c) + 2) for c in modes[m].keys()]
        if l != []: (s, w) = l[-1]; l[-1] = (s[:-2], w - 2) # remove last comma
        print(indented_and_wrapped(l, indent), end='\n\n')
    # todo: built-ins

def cmd_define(cmd):
    mm = [mode]
    if mode != idle_mode:
        mm += [m for m in modes if m != mode and mode_is_auto_enabled(m)]
    for m in mm:
        for pattern, expansion in modes[m].items():
            if pattern.split()[0] == cmd:
                print('\nin', color_mode(m) + ',',
                    color_commands(pattern), '=',
                    color_commands(expansion), end='\n\n')
                return
    sound('bad.wav', 1, wait=False)
    print(colored('no such command: ' + cmd, 'red'))

def cmd_press(spec):
    for combo in spec.split(','):
        times = 1
        mult = combo.find('*')
        if mult != -1:
            times = int(combo[:mult])
            combo = combo[mult+1:]
        keys = combo.split('+')
        if len(keys) == 1:
            k = key_by_name(keys[0])
            pyautogui.press([k] * times)
        else:
            for i in range(0, times):
                for k in keys: press_key(k)
                time.sleep(0.05)
                for k in reversed(keys): release_key(k)

def cmd_run(cmd):
    subprocess.Popen(cmd, shell=True,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)

def cmd_printline(s):
    print(colored(s, 'magenta'))

def cmd_execute(cmd):
    output = subprocess.Popen(cmd, shell=True,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE).stdout.read().decode('utf-8').strip()
    cmd_printline(output)

def cmd_sleep(s):
    if not s.isdigit():
        print(colored('sleep takes a number', 'red'))
        return
    time.sleep(int(s))

nullary_builtin_commands = {
    'stop': lambda: switch_mode(idle_mode),
    'options': cmd_options,
    'nop': lambda: None
}

unary_builtin_commands = {
    'keydown': press_key,
    'keyup': release_key,
    'press': cmd_press,
    'run': cmd_run,
    'execute': cmd_execute,
    'text': cmd_text,
    'define': cmd_define,
    'sleep': cmd_sleep,
    'printline': cmd_printline
}

# command evaluation:

def param_matched(param, arg, i):
    if param in [arg, '<word>']: return (True, [])
    if param == '<number>' and arg[0].isdigit(): return (True, [])
    for e in enums:
        if param == '<' + e + '>':
            enumerators = enums[e].split()
            if arg in enumerators:
                return (True, [('enumindex' + str(i), str(enumerators.index(arg)))])
    return (False, [])

def params_matched(params, args):
    vars = []
    for i in range(0, len(params)):
        if i == len(args): return (i, vars)
        b, v = param_matched(params[i], args[i], i)
        if not b: return (i, vars)
        vars += v
    return (len(params), vars)

def mode_is_auto_enabled(m):
    global current_application, current_windowtitle
    aliases = modes[m]
    if (m in auto_enable_for_applications and
      current_application in auto_enable_for_applications[m]):
        return True
    if m in auto_enable_for_prefixes:
        for prefix in auto_enable_for_prefixes[m]:
            if current_windowtitle.startswith(prefix):
                return True
    if m in auto_enable_for_suffixes:
        for suffix in auto_enable_for_suffixes[m]:
            if current_windowtitle.endswith(suffix):
                return True
    return False

def get_active_modes(mode):
    r = [mode]
    if mode != idle_mode:
        for m in modes:
            if m != mode and mode_is_auto_enabled(m):
                r.append(m)
    return r

def color_commands(p):
    return colored(p, 'magenta')

def color_mode(m):
    return colored(m, 'cyan')

def handle_alias(words, mode, include_autoenabled):
    if words == []: return (0, 0, [], mode)
    cmd, *rest = words

    mm = [mode]
    if include_autoenabled and mode != idle_mode:
        mm += [m for m in modes if m != mode and mode_is_auto_enabled(m)]

    for m in mm:
        for pattern, expansion in modes[m].items():
            params = pattern.split()
            matched, vars = params_matched(params, words)
            if matched == len(params):
                exp = expansion.split()
                vars += [(str(i), words[i]) for i in range(0, matched)]
                vars.append(('application', current_application))
                vars.append(('windowtitle', current_windowtitle))
                for varname, varvalue in vars:
                    exp = [tok.replace('$' + varname, varvalue) for tok in exp]
                n, _, acts, mode = process(exp, m, True, False)
                if n != len(exp):
                    print(colored('\nerror: bad alias:', 'red'),
                        color_mode(m) + ' ' + color_commands(pattern) + ':',
                        color_commands(expansion))
                return (matched, 0, acts, mode)
            elif matched != 0:
                missing = len(params) - matched
                return (matched, missing, [], mode)

    return (0, 0, [], mode)

def handle_builtin_command(words, mode):
    if words == []: return (0, 0, [], mode)
    cmd, *args = words
    if cmd in nullary_builtin_commands:
        return (1, 0, [nullary_builtin_commands[cmd]], mode)
    if cmd in unary_builtin_commands:
        if args == []: return (1, 1, [], mode)
        arg, *rest = args
        return (2, 0, [lambda: unary_builtin_commands[cmd](arg)], mode)
    if cmd == 'switch':
        if args == []: return (1, 1, [], mode)
        arg, *rest = args
        if arg in modes: return (2, 0, [lambda: switch_mode(arg)], arg)
    return (0, 0, [], mode)

def process(words, mode, handle_builtins, include_autoenabled):
    # returns (n, missing, acts, newmode) where n is how many words were recognized, and acts is a list of actions

    if words == []: return (0, 0, [], mode)
    cmd, *args = words

    n, missing, acts, mode2 = handle_alias(words, mode, include_autoenabled)
    if missing != 0:
        return (n, missing, acts, mode)
    if n != 0:
        m, missing, acts2, mode3 = process(words[n:], mode2, True, include_autoenabled)
        return (n + m, missing, acts + acts2, mode3)

    if handle_builtins:
        n, missing, acts, mode2 = handle_builtin_command(words, mode)
        if missing != 0:
            return (n, missing, acts, mode)
        if n != 0:
            m, missing, acts2, mode3 = process(words[n:], mode2, True, include_autoenabled)
            return (n + m, missing, acts + acts2, mode3)

    return (0, 0, [], mode)

# input preprocessing:

def replace_numbers(words, collected=''):
    if words == []: return ([collected] if collected != '' else [])
    first, *rest = words
    if first in numbers: return replace_numbers(rest, collected + numbers[first])
    if collected != '': return [collected, first] + replace_numbers(rest)
    return [first] + replace_numbers(rest)

def replace_words(words):
    if words == []: return []
    for i in range(0, len(words)):
        for k, vv in word_replacements.items():
            for v in vv:
                kw = v.split()
                if len(words) >= i + len(kw) and words[i:i+len(kw)] == kw:
                    return words[:i] + k.split() + replace_words(words[i+len(kw):])
    return words

async def process_lines(input):
    global mode
    loop = asyncio.get_event_loop()
    reader = asyncio.StreamReader(loop=loop, limit=asyncio.streams._DEFAULT_LIMIT)
    await loop.connect_read_pipe(
        lambda: asyncio.StreamReaderProtocol(reader, loop=loop), input)

    print_prompt()
    last_active_modes = get_active_modes(mode)

    while True:
        try:
            line = await asyncio.wait_for(reader.readline(), 0.5)
        except asyncio.TimeoutError:
            get_current_application()
            m = get_active_modes(mode)
            if last_active_modes != m:
                last_active_modes = m
                print_prompt()
        else:
            if not line: break # EOF
            else:
                line = line.decode('utf-8').rstrip('\n')
                if line == '' or line[0] == '#' or line in ignore: continue

                load_config()

                words = replace_numbers(replace_words(line.split()))
                if len(words) > 0 and words[0] in ['the', 'a', 'i', 'and']:
                    words.pop(0)

                if words == []: continue

                handle_builtins = (mode != idle_mode)
                n, missing, acts, newmode = process(words, mode, handle_builtins, True)
                confirm_input(words, n, missing, newmode)
                for a in acts: a()
                print_prompt()
                last_active_modes = get_active_modes(mode)

# output:

def sound(n, count=1, wait=True):
    if count == 0 or not sound_effects: return
    pygame.mixer.music.load("sounds/" + n)
    for i in range(0, count):
        pygame.mixer.music.play()
        if wait:
            while pygame.mixer.music.get_busy(): time.sleep(0.01)
            time.sleep(0.1)

def short_mode_name(mode):
    return (short_mode_names[mode] if mode in short_mode_names else mode)

def print_prompt():
    modes = get_active_modes(mode)
    print('\r' + ' ' * 50 + '\r' +
        ','.join(map(
        lambda s: color_mode(short_mode_name(s)),
        modes)) + '> ', end='')
    sys.stdout.flush()

def confirm_input(words, n, missing, newmode):
    if n == 0:
        print(colored(' '.join(words), 'yellow'))
        return
    print(colored(' '.join(words[:n]), 'green'), end='')
    if n != len(words):
        if n != 0: print(' ', end='')
        print(colored(' '.join(words[n:]), 'red'), end='')
    elif missing != 0:
        print(colored(' <???>', 'red'), end='')
    print()

    sound('good.wav', n)
    if n != len(words) or missing != 0:
        sound('bad.wav', 1, wait=False)

def simple_subprocess(cmd):
    p = subprocess.Popen(cmd, shell=True,
        stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return p.stdout.read().decode('utf-8').rstrip()

def get_current_application():
    global current_application, current_windowtitle
    current_windowtitle = ''
    current_application = ''
    active_win = simple_subprocess('xdotool getactivewindow')
    if active_win == '': return
    current_windowtitle = simple_subprocess('xdotool getwindowname ' + active_win)
    pid = simple_subprocess('xdotool getwindowpid ' + active_win)
    current_application = (psutil.Process(int(pid)).name() if pid != '' else '')

pygame.init()
pygame.mixer.music.set_volume(0.03)
    # very low so our beeps are (a) non-obnoxious, and (b) won't interfere with speech recognition

asyncio.get_event_loop().run_until_complete(process_lines(sys.stdin))
